#include "Rohan.h"
#include "Rohan-data.h"
#include "Rohan-io.h"
#include "Rohan-learn.h"
#include "Rohan-menu.h"
#include "Rohan-kernel.h"
#include "Rohan-class.h"
#include "ShowMe.h"
#include "stdafx.h"
#include <conio.h> //for _getch 

#include <cuda.h>
#include <cublas.h>
#include <cutil_inline.h>
#include <cuda_runtime_api.h>
#include <multithreading.h>

//#include <time.h> // for tsrtuct
#include <sys/timeb.h>
#include <iostream>
#include <stdlib.h>
using namespace std;
using std::cin;
using std::cout;

#define TWO_PI 6.283185307179586476925286766558
#define IDX2C(i,j,ld) (((j)*(ld))+(i))

extern int iDebugLvl, iWarnings, iErrors, iTrace;
extern bool bCublasAvailable;

//////////////// class cDrover begins ////////////////

void cDrover::ShowMe()
{
	//ShowMeSes(* rSes, false);
	printf("Am Volga boatman.\n");
}

long cDrover::SetContext( rohanContext& rC)
{/// enables pointer access to master context struct
	rSes = &rC;
	return 0;
}

long cDrover::SetDroverBargeAndTeam( class cDrover * cdDrover, class cBarge * cbBarge, class cTeam * ctTeam)
{mIDfunc /// sets pointers to hitch barge to team and mount driver on barge
	Barge = cbBarge;
	Team = ctTeam;
	Barge->SetDrover(cdDrover);
	Barge->SetTeam(Team);
	Team->SetDrover(cdDrover);
	Team->SetBarge(Barge);
	return 0;
}

long cDrover::ObtainGlobalSettings(struct rohanContext& rSes)
{mIDfunc /// sets initial and default value for globals and settings
	int iReturn=0;
	cublasStatus csStatus;
	//	globals
	iTrace=0; cout << "Tracing is "; (iTrace ? cout << "on\n" : cout << "off.\n" );
	iDebugLvl=0; cout << "Debug level is " << iDebugLvl << "\n";
	// session accrual
	rSes.iWarnings=0; rSes.iErrors=0; cout << "Session warning and session error counts reset.\n";
	rSes.lSampleQtyReq=0;
	// session modes
	rSes.bContActivation=true; cout << "Activation default is CONTINUOUS.\n";
	
	rSes.bRInJMode=false; cout << "Reversed Input Order is OFF.\n"; // this is working backward for some reason 2/08/11
	rSes.bRMSEon=true; cout << "RMSE stop condition is ON. XX\n"; //
	rSes.iEpochLength=1000; cout << "Epoch length is 1000 iterations.\n";
	strcpy(rSes.sSesName,"DefaultSession");
	// session member objects
	rSes.rLearn=new struct rohanLearningSet;
	rSes.rNet=new rohanNetwork;
	// scratch space
	csStatus=cublasAlloc(1024, sizeof(double), (void**)&(rSes.rLearn->gpudSE1024)); 
			mCuMsg(csStatus,"cublasAlloc()")

	return iReturn;
}

long cDrover::DoAnteLoop(int argc, char * argv[], class cDrover * cdDrover, class cBarge * cbBarge, class cTeam * ctTeam)
{mIDfunc /// This function prepares all parameters, contexts, and data structures necesary for learning and evaluation.
	int iReturn=0;

	// initiate relationship
	SetDroverBargeAndTeam( cdDrover, cbBarge, ctTeam);
	
	if (argc) {
		rSes->bConsoleUsed=false;
		rSes->bCLargsUsed=true;
		// call function to parse CLI args here
	}
	else {
		rSes->bConsoleUsed=true;
		rSes->bCLargsUsed=false;
	} /// potentially abusable 
	printf("Rohan v%s Neural Network Application\n", VERSION);
	//print_NVCC_min_spec();
	iTrace=0;
	if (CublasVerify(*rSes)){
		cout << "CUBLAS present" << endl;
		iReturn=ObtainGlobalSettings(*rSes);
		if (Barge->ObtainSampleSet(*rSes)){
			iReturn=Barge->DoPrepareNetwork(*rSes);
			iReturn=ShowDiagnostics(*rSes);
		}
		else {
			cout << "Failed to load samples" << endl;
		}
	}
	else {
		fprintf(stderr, "Unrecoverable Error: No CUDA hardware or no CUBLAS functions present.\n", ++rSes->iErrors);
		iReturn=0;
	}
	return iReturn;

	//return AnteLoop(rSes, argc, argv);
}

long cDrover::DoMainLoop(struct rohanContext& rSes)
{mIDfunc /// Trains a weight set to more closely reproduce the sampled outputs from the sampled inputs, and other options.
	int iReturn=0, iSelect=1;
	cout << "Main duty loop begin." << endl;
	
	while(iSelect){
		iSelect=DisplayMenu(0, rSes);
		if (iSelect==1) iReturn=BeginSession(rSes); // new or resume session
		if (iSelect==2) iReturn=GetNNTop(rSes);
		if (iSelect==3) iReturn=ReGetSampleSet(rSes);
		if (iSelect==4) iReturn=GetWeightSet(rSes);
		if (iSelect==5) iReturn=InteractiveEvaluation(rSes);
		if (iSelect==6) iReturn=InteractiveLearning(rSes);
		if (iSelect==7) iReturn=cuPreSaveNNWeights(rSes);
		if (iSelect==8) iReturn=Barge->DoDualRandomizeWeights(rSes);
		//if (iSelect==8) iReturn=TestPatLS(rSes, false)+ShowMeLS(rSes, false)+ShowMeST(rSes, false)+TestPatWS(rSes, false)+ShowMeWS(rSes, false)+ShowMeSes(rSes, false);
		//if (iSelect==9) iReturn=devResetAllDeltasAndOutputs(rSes)+ShowMeErr(rSes, false)+ShowMeLS(rSes, true)+ShowMeWS(rSes, false)+ShowMeSes(rSes, false);
		//if (iSelect==9) iReturn=devResetAllDeltasAndOutputs(rSes)+ShowMeErr(rSes, false)+ShowMeLS(rSes, false)+ShowMeWS(rSes, false)+ShowMeSes(rSes, false);
		if (iSelect==9) {
			printf("dev RMSE %f\n", knlRMSE(rSes,0));
			rSes.dTargRMSE=0.1;
			rSes.dMAX=10.0;
			rSes.iEpochLength=1;
			rSes.lSampleQtyReq=2;
			long count = 0; rSes.lSamplesTrainable=1; //set trainable to 1 to allow loop to proceed at least once
			while(rSes.dTargRMSE<rSes.dRMSE && rSes.lSamplesTrainable && count < rSes.iEpochLength){ // target not met, trainable samples left
				rSes.lSamplesTrainable=TrainNNThresh(rSes , true);
				cuEvalNNLearnSet(rSes);
				devEvalNNLearnSet(rSes);
				rSes.dRMSE = RmseNN(rSes, 0);
				printf(" RMSE = % #3.5g/% #3.5g, iteration %d\n", rSes.dRMSE, knlRMSE(rSes,0), ++count);
			}
		}
		SilentDiagnostics(rSes);
	}

	//return MainLoop(rSes);
	//MainLoop(rSes);
	return 0;
}

long cDrover::DoEndItAll(struct rohanContext& rSes)
{mIDfunc /// prepares for graceful ending of program
	int iReturn=0;
	cublasStatus csStatus;

	iReturn=Barge->DoCuFree(rSes);
	csStatus=cublasShutdown(); // release any CUBLAS resources
	if(csStatus==CUBLAS_STATUS_NOT_INITIALIZED) { printf("CUBLAS library not initialized\n"); return iReturn;}
	else printf("CUBLAS resources released\n");
		mCuMsg(csStatus,"cublasShutdown()")

	return iReturn;
}


long cDrover::DoPostLoop(struct rohanContext& rSes) 
{mIDfunc /// Final operations including freeing of dynamically allocated memory are called from here. 
	int iReturn=0, iSelect=0;

	printf("Program terminated after %d warning(s), %d operational error(s).\n", rSes.iWarnings, rSes.iErrors);
	DoEndItAll(rSes);
	printf("Waiting on keystroke...\n");
	_getch();

	return 0;
}
